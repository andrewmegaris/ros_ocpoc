#!/usr/bin/env python

#This is the subscriber node for the ulanding publisher node
#It will calculate if avoidance should be called
#Eventually this node will read in two radars for multi directional avoidance.
# Author: Andrew Megaris
# Date: 5/16/2017
# Email: andrew@aerotenna.com
# Github: https://github.com/andrewmegaris

import rospy
import time
from std_msgs.msg import String

#DEFINE AVOIDANCE_RANGE
AVOIDANCE_RANGE = 300
avoiding = True
timer = 0

def process_data(data):
    global avoiding
    global timer
    global AVOIDANCE_RANGE
    objectRange = data.data
    #first check if currently avoiding. 
    if(avoiding):
        print("currently avoiding")
        #if object is in the way, continue avoiding
        if(int(objectRange) <= AVOIDANCE_RANGE):
            timer = timer + 1
            #TODO STEER RIGHT
            print("steering right: " + str(timer))
        #Object has been avoided, get back onto path.
        else:
            while(int(timer) != 0):
                timer = timer - 1
                print("steering left: " + str(timer))
                #TODO STEER LEFT
            avoiding = False
            print("object passed")
    #if not currently avoiding
    else:
        if(int(objectRange) <= 300):
            print("activating avoidance")
            #if an object is within specified range, enable avoidance.
            #JUMP OUT OF MISSION MODE
            avoiding = True
        else:
            print("dont need to avoid" + str(AVOIDANCE_RANGE))
            
def ulanding_listener():
    rospy.init_node('ulanding_listener', anonymous=True)
    rospy.Subscriber('ulanding_chatter', String, process_data)
    rospy.spin()

if __name__ == '__main__':
    ulanding_listener()
